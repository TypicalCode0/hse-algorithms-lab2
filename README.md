# Лабораторная 2
| | |
|--------------- | --------------- |
| Выполнил   | Аладышев Дмитрий 22ПИ-3   |
| Логин в контесте   |  daaladyshev@edu.hse.ru  |
| Исходники с контеста | [main.cpp](./src/contest/main.cpp) |
## Задача
Дано `N` прямоугольников на плоскости с углами в целочисленных координатах
 и `M` точек. Требуется как можно быстрее выдавать ответ на вопрос «Скольким прямоугольникам принадлежит точка
x
,
y
?». Если точка находится на границе прямоугольника, то считается, что она принадлежит ему. Подготовка данных должна занимать как можно меньше времени.
### Цель
Реализовать три разных решений задачи. Выяснить: при каком объеме начальных данных и точек эффекетивен каждый из алгоритмов.
## Реализация алгоритмов
## Полный перебор
Поиск `O(N * M)`, где `M` - количество точек, `N` - количество прямоугольников.
Данный алгоритм подразумевает поочерёдный перебор каждого из прямоугольников для проверки: принадлежит ли точка текущему прямоугольнику. Дополнительная обработка данных не производится.
```C++
  size_t get_number_intersections(std::vector<Rectangle> &rectangles, Point point) {
    size_t count = 0;
    for (auto rectangle: rectangles) {
      if (point >= rectangle.lower_left_point && 
          point < rectangle.upper_right_point) {
        ++count;
      }
    }
    return count;
  }
```
## Алгоритм на карте со сжатием координат.
Подготовка `O(N^3)`, поиск `O(M * logN)`, где `M` - количество точек, `N` - количество прямоугольников.
Сожмем все координаты прямоугольников. Построим двумерный массив, который и будет отрисовывать наши сжатые прямоугольники. Тогда, чтобы ответить на запрос, нам нужно сжать координату точки и найти соответствующий элемент в карте.
*Подготовка:*
```C++
    MapAlgorithm(std::vector<Rectangle>& rectangles) {
        for (auto r: rectangles) {
            x_coords.insert(r.lower_left_point.x);
            y_coords.insert(r.lower_left_point.y);
            x_coords.insert(r.upper_right_point.x);
            y_coords.insert(r.upper_right_point.y);
        }

        int index = 0;
        for (auto it:x_coords) {
            value_to_id_x.insert({it, index++});
        }
        index = 0;
        for (auto it:y_coords) {
            value_to_id_y.insert({it, index++});
        }
        map = std::vector<std::vector<int>>{value_to_id_x.size(), std::vector<int>(value_to_id_y.size(), 0)};

        for (auto r:rectangles) {
            int max_i = value_to_id_x[r.upper_right_point.x];
            int max_j = value_to_id_y[r.upper_right_point.y];
            for (int i = value_to_id_x[r.lower_left_point.x]; i < max_i; ++i) {
                for (int j = value_to_id_y[r.lower_left_point.y]; j < max_j; ++j) {
                    ++map[i][j];
                }
            }
        }
    }
```
*Ответ на запрос:*
```C++
    size_t get_number_intersections(Point point) {
        int x = *(--x_coords.upper_bound(point.x));
        int y = *(--y_coords.upper_bound(point.y));
        if (x < *x_coords.begin() || x > *(--x_coords.end()) || 
            y < *y_coords.begin() || y > *(--y_coords.end())) {
            return 0;
        }
        return map[value_to_id_x[x]][value_to_id_y[y]];
    }
```
### Алгоритм на персистентном дереве отрезков
Подготовка, `O(N * logN)`, Поиск`O(M * logN)`,  где `M` - количество точек, `N` - количество прямоугольников.
Сожмем координаты прямоугольников. Отсортируем прямоугольники по иксу. Далее пройдемся по всем иксам и будем добавлять в дерево нижнюю и верхнюю границу по `y` и 1, если прямоугольник в соответствующей вершине появился и -1, если закончился. Тогда, чтобы ответить на запрос, нам достаточно сжать координату точки, найти какой версии соответствует сжатая координата х и взять элемент по у в дереве.
Код можно найти тут: [PersistentSegmentTree](./src/algorithms/PersistentSegmentTree.hpp)
### Тестирование и выводы
Данные для проведения тестов генерировались по следующим условиям:
- Для тестового набора прямоугольников - набор вложенных друг в друга прмоугольников. имеющих координаты с шагом больше 1:
`{(10*i, 10*i), (10*(2*N-i), 10*(2*N-i))}`.
- Для тестового набора точек - неслучайный набор координат точек распределенных равномерно по ненулевому пересечению прямоугольников - хэш функции от i с разным базисом для x и y:
`(p*i)^31%(20*N)`, p - большое простое, разное для x и y.
- Количество прямоугольников равно `2 ^ i`, где `0 <= i <= 12`
- Количество точек для каждого из значений `i` равнялось `100000`

Для двух алгоритмов требовалась подготовка данных, поэтому было рассмотрены две фазы:
- предобработка
- поиск ответа
### Измерение времени подготовки
![image](https://github.com/TypicalCode0/hse-algorithms-lab2/assets/131657894/d95b20e4-7318-48dd-9b62-360e8cbdaf10)
![image](https://github.com/TypicalCode0/hse-algorithms-lab2/assets/131657894/95233a82-a9cd-48a0-aede-bcab75a9ca34)
### Измерение поиска ответа
![image](https://github.com/TypicalCode0/hse-algorithms-lab2/assets/131657894/d7bb9030-b93f-447b-9bcb-ddf5c727400d)
![image](https://github.com/TypicalCode0/hse-algorithms-lab2/assets/131657894/4efef372-249a-4334-858e-b4c875e14af0)
Из графиков видно что BruteForceAlgorithm самый эффективный для малого количества прямоугольников(до 128), так как не требует никакой подготовки и работает достаточно быстро. При большем количестве прямоугольников лучше всего отвечает на запросы MapAlgorithm, но он также занимает наибольшее время при подготовке и требует наибольшее количество памяти. PersistentSegmentTreeAlgorithm требует меньшее количество памяти, но медленнее отвечает на запрос, зато быстрее выполняет подготовку к запросам чем MapAlgorithm, особенно при больших данных(количество прямоугольников больше 1024)



